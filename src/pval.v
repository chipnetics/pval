import os
import flag
import arrays
import time

fn main() {

	mut fp := flag.new_flag_parser(os.args)
	fp.application('pval')
	fp.version('v0.0.1\nCopyright (c) 2022 jeffrey -at- ieee.org. All rights reserved.\nUse of this source code (/program) is governed by an MIT license,\nthat can be found in the LICENSE file.')
	fp.description('\nOutput pdf,cdf distribution from input.\nNote that columns are 0-index based.')
	fp.skip_executable()
	pivot_column_arg := fp.int('column', `c`, -1, 'Column index to generate distribution from')
	is_date := fp.bool('is-date', `d`, false, 'Indicate column is date (fmt: yyyy-mm-dd)')
	mut bin_size_arg := fp.int('binsize', `b`, 0, 'Bin sizing')
	mut has_header := fp.bool('no-header', `n`, false, 'Indicate input file has no header')
	do_expand := fp.bool('expand', `e`, false, 'Expand output generated by pval')
	file_in := fp.string('file-in', `f`, '', 'Input file')

	has_header = !has_header // flip the argument (readibility)

	additional_args := fp.finalize() or {
		eprintln(err)
		println(fp.usage())
		return
	}

	// Expand file generated by pval, in a previous execution.
	if do_expand && file_in.len != 0
	{
		expand_gen(file_in,is_date)
		return
	}

	if pivot_column_arg <= -1 || bin_size_arg == 0 || file_in.len == 0 {
		println(fp.usage())
		return
	}

	additional_args.join_lines()

	lines := os.read_lines(file_in) or { panic(err) }

	mut collection := []f64{}

	for index, line in lines {
		if index == 0 && has_header {
			continue
		}

		delimited_row := line.split('\t')

		// For mal-formed data
		if delimited_row.len > pivot_column_arg {
			if !is_date {
				collection << delimited_row[pivot_column_arg].f64()
			}
			else if is_date {
				time_s := time.parse("${delimited_row[pivot_column_arg]} 00:00:00") or 
				{eprintln("Error parsing date. Be sure format is yyyy-mm-dd") return}

				//println("${time_s.unix_time()}")
				collection << time_s.unix_time()
			}
		}
	}

	/////////////////////////////
	/// Setup bin data struct ///
	/////////////////////////////
	maximum_in := arrays.max(collection) ?
	minimum_in := arrays.min(collection) ?

	if is_date {
		bin_size_arg = bin_size_arg*86400 // epoch day
	}
	
	bin_numbers := ((maximum_in-minimum_in)+1) / bin_size_arg
	mut bins_array := []Bin{}
	for i := 0; i < bin_numbers; i++ {
		a_bin := Bin{}
		bins_array << a_bin
	}

	// Find which bin belongs to
	for elem in collection 
	{
		for i := 0; i < bin_numbers; i++ 
		{
			//println("$elem [${(minimum_in + i * bin_size_arg)},${(minimum_in + (i + 1) * bin_size_arg)}]")
			if elem >= (minimum_in + i * bin_size_arg) &&
			   elem < (minimum_in + (i + 1) * bin_size_arg)
			{
				bins_array[i].count++
				break
			}
		}
	}

	//////////////////
	/// Create CDF ///
	//////////////////
	println('bin\tlower_bound\tupper_bound\tdsc_count\tcml_count\tpdf\tcdf')

	mut total_count := 0.0
	for bin in bins_array {
		total_count += bin.count
	}

	mut a_cdf := CDF{}

	mut rolling_count := 0.0
	for bin in bins_array {
		rolling_count += bin.count

		a_cdf.cum_count << rolling_count
		a_cdf.cum_percent << rolling_count / total_count
		a_cdf.disc_percent << bin.count / total_count
	}

	////////////////////
	/// Print result ///
	////////////////////
	if is_date
	{
		for index, _ in a_cdf.cum_count {

			date_low := time.unix(i64(minimum_in+index*bin_size_arg))
			date_high := time.unix(i64(minimum_in+(index+1)*bin_size_arg))
			println('${index+1}\t\
					${date_low.year:04}-${date_low.month:02}-${date_low.day:02}\t\
					${date_high.year:04}-${date_high.month:02}-${date_high.day:02}\t\
					${bins_array[index].count}\t\
					${a_cdf.cum_count[index]}\t\
					${a_cdf.disc_percent[index]:0.16f}\t\
					${a_cdf.cum_percent[index]:0.16f}\
					')
		}
	}
	else
	{
		for index, _ in a_cdf.cum_count {
			bin_low := minimum_in+index*bin_size_arg
			bin_high := minimum_in+(index+1)*bin_size_arg

			println('${index+1}\t\
					${bin_low}\t\
					${bin_high}\t\
					${bins_array[index].count}\t\
					${a_cdf.cum_count[index]}\t\
					${a_cdf.disc_percent[index]:0.16f}\t\
					${a_cdf.cum_percent[index]:0.16f}\
					')
		}
	}
}

fn expand_gen(file_in string,is_date bool)
{
	lines := os.read_lines(file_in) or 
			{ eprintln("Failed to open input file. Does it exist?")
			  exit(0)
			 }

	mut i:=0.0
	mut prev_cdf := 0.00

	for index, line in lines
	{
		// Skip header
		if index == 0  {
			continue
		}

		line_arr := line.split("\t")

		cdf_val := line_arr[6].f64()
		mut low_bnd := line_arr[1].f64()
		mut upp_bnd := line_arr[2].f64()
		
		if is_date // if date re-write low/upp_bnd with unix time.
		{
			low_bnd_t := time.parse("${line_arr[1]} 00:00:00") or 
					{eprintln("Error parsing date on line ${index}") exit(0)}
			upp_bnd_t := time.parse("${line_arr[2]} 00:00:00") or 
					{eprintln("Error parsing date on line ${index}") exit(0)}
			
			low_bnd = low_bnd_t.unix_time()
			upp_bnd = upp_bnd_t.unix_time()
		}

		for i <= cdf_val
		{
			mut interpol := (i - prev_cdf)*upp_bnd/(cdf_val-prev_cdf) +
							(cdf_val-i)*low_bnd/(cdf_val-prev_cdf) 

			p_int := int(i*100)

			if !is_date
			{
				println("P${p_int:02}\t\
						${i:.02f}\t\
						$low_bnd\t\
						$upp_bnd\t\
						${interpol:0.3f}")
			}
			else
			{
				date_low := line_arr[1]
				date_high := line_arr[2]

				interp_date := time.unix(i64(interpol))

				println("P${p_int:02}\t\
						${i:.02f}\t\
						$date_low\t\
						$date_high\t\
						${interp_date.year:04}-${interp_date.month:02}-${interp_date.day:02}\
						")
			}

			i+=0.01
		}

		// new bin
		prev_cdf = cdf_val
	}

	// print P100
	line_arr := lines[lines.len-1].split("\t")
	println("\
		P100\t\
		1.00\t\
		${line_arr[1]}\t\
		${line_arr[2]}\t\
		${line_arr[2]}\
	")
}

struct CDF {
mut:
	cum_count    []f64
	cum_percent  []f64
	disc_percent []f64
}

struct Bin {
mut:
	count int
}
